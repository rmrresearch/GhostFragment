#include "fragment.hpp"
#include <catch2/catch.hpp>

using namespace testing;

/* The actual function wraps the system generated by the water function (so that
 * part should be right since the water function works and is unit tested) and
 * then defines fragments assuming that the waters are laid out in the same
 * order as the water function does (i.e. O, H, H). We test fragmented_water for
 * 0, 1, 2, and 3 waters, assuming that if it works for all those cases it'll
 * keep working. Testing of fragmented_water_needing_caps is done analogously
 */

TEST_CASE("fragmented_water") {
    using frag_type = ghostfragment::type::fragmented_molecule;
    using size_type = frag_type::value_type::size_type;

    SECTION("Zero waters") {
        frag_type corr(water(0));
        REQUIRE(corr == fragmented_water(0));
    }

    SECTION("One water") {
        frag_type corr(water(1));
        auto w0 = corr.new_subset();
        w0.insert(0);
        w0.insert(1);
        w0.insert(2);
        corr.insert(w0);
        REQUIRE(corr == fragmented_water(1));
    }

    SECTION("Two waters") {
        frag_type corr(water(2));
        auto w0 = corr.new_subset();
        w0.insert(0);
        w0.insert(1);
        w0.insert(2);
        corr.insert(w0);
        auto w1 = corr.new_subset();
        w1.insert(3);
        w1.insert(4);
        w1.insert(5);
        corr.insert(w1);
        REQUIRE(corr == fragmented_water(2));
    }

    SECTION("Three waters") {
        frag_type corr(water(3));
        auto w0 = corr.new_subset();
        w0.insert(0);
        w0.insert(1);
        w0.insert(2);
        corr.insert(w0);
        auto w1 = corr.new_subset();
        w1.insert(3);
        w1.insert(4);
        w1.insert(5);
        corr.insert(w1);
        auto w2 = corr.new_subset();
        w2.insert(6);
        w2.insert(7);
        w2.insert(8);
        corr.insert(w2);
        REQUIRE(corr == fragmented_water(3));
    }
}

TEST_CASE("fragmented_water_needing_caps") {
    using frag_type = ghostfragment::type::fragmented_molecule;
    using size_type = frag_type::value_type::size_type;

    SECTION("Zero waters") {
        frag_type corr(water(0));
        REQUIRE(corr == fragmented_water_needing_caps(0));
    }

    SECTION("One water") {
        frag_type corr(water(1));
        auto w0 = corr.new_subset();
        w0.insert(0);
        w0.insert(1);
        auto w1 = corr.new_subset();
        w1.insert(2);
        corr.insert(w0);
        corr.insert(w1);
        REQUIRE(corr == fragmented_water_needing_caps(1));
    }

    SECTION("Two waters") {
        frag_type corr(water(2));

        auto w0 = corr.new_subset();
        w0.insert(0);
        w0.insert(1);

        auto w1 = corr.new_subset();
        w1.insert(2);

        auto w2 = corr.new_subset();
        w2.insert(3);
        w2.insert(4);

        auto w3 = corr.new_subset();
        w3.insert(5);

        corr.insert(w0);
        corr.insert(w1);
        corr.insert(w2);
        corr.insert(w3);

        REQUIRE(corr == fragmented_water_needing_caps(2));
    }

    SECTION("Three waters") {
        frag_type corr(water(3));

        auto w0 = corr.new_subset();
        w0.insert(0);
        w0.insert(1);

        auto w1 = corr.new_subset();
        w1.insert(2);

        auto w2 = corr.new_subset();
        w2.insert(3);
        w2.insert(4);

        auto w3 = corr.new_subset();
        w3.insert(5);

        auto w4 = corr.new_subset();
        w4.insert(6);
        w4.insert(7);

        auto w5 = corr.new_subset();
        w5.insert(8);

        corr.insert(w0);
        corr.insert(w1);
        corr.insert(w2);
        corr.insert(w3);
        corr.insert(w4);
        corr.insert(w5);

        REQUIRE(corr == fragmented_water_needing_caps(3));
    }
}
