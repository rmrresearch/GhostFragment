<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ghostfragment: ghostfragment::Caps Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ghostfragment
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ghostfragment</b></li><li class="navelem"><a class="el" href="classghostfragment_1_1Caps.html">Caps</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classghostfragment_1_1Caps-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghostfragment::Caps Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A set of caps.  
 <a href="classghostfragment_1_1Caps.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="caps_8hpp_source.html">caps.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0da5dfb727b6f9af564d6470ddabc5ca"><td class="memItemLeft" align="right" valign="top"><a id="a0da5dfb727b6f9af564d6470ddabc5ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a0da5dfb727b6f9af564d6470ddabc5ca">value_type</a> = cap_set_type::value_type</td></tr>
<tr class="memdesc:a0da5dfb727b6f9af564d6470ddabc5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type like chemist::Atom. <br /></td></tr>
<tr class="separator:a0da5dfb727b6f9af564d6470ddabc5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fa35cb356218c57855b182e13b3ccc"><td class="memItemLeft" align="right" valign="top"><a id="ae0fa35cb356218c57855b182e13b3ccc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">const_reference</a> = const <a class="el" href="classghostfragment_1_1Caps.html#a0da5dfb727b6f9af564d6470ddabc5ca">value_type</a> &amp;</td></tr>
<tr class="memdesc:ae0fa35cb356218c57855b182e13b3ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a cap. <br /></td></tr>
<tr class="separator:ae0fa35cb356218c57855b182e13b3ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30da1c9722a0347727fdc31485ba1eca"><td class="memItemLeft" align="right" valign="top"><a id="a30da1c9722a0347727fdc31485ba1eca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a> = cap_set_type::size_type</td></tr>
<tr class="memdesc:a30da1c9722a0347727fdc31485ba1eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type. <br /></td></tr>
<tr class="separator:a30da1c9722a0347727fdc31485ba1eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8cc86d0db9ae98bb6748292b65e0b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67">size</a> () const noexcept</td></tr>
<tr class="memdesc:af8cc86d0db9ae98bb6748292b65e0b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of caps in this instance.  <a href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67">More...</a><br /></td></tr>
<tr class="separator:af8cc86d0db9ae98bb6748292b65e0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd2c379294b50889dda9ae8eb5d437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#ae2dd2c379294b50889dda9ae8eb5d437">count</a> (<a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">const_reference</a> cap) const noexcept</td></tr>
<tr class="memdesc:ae2dd2c379294b50889dda9ae8eb5d437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a cap is in the present set.  <a href="classghostfragment_1_1Caps.html#ae2dd2c379294b50889dda9ae8eb5d437">More...</a><br /></td></tr>
<tr class="separator:ae2dd2c379294b50889dda9ae8eb5d437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7d9ecdc9068b3fd4a77bb9c949ce50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a9a7d9ecdc9068b3fd4a77bb9c949ce50">add_cap</a> (<a class="el" href="classghostfragment_1_1Caps.html#a0da5dfb727b6f9af564d6470ddabc5ca">value_type</a> cap, <a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a> idx_replaced)</td></tr>
<tr class="memdesc:a9a7d9ecdc9068b3fd4a77bb9c949ce50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cap (and the index of the replaced atom)  <a href="classghostfragment_1_1Caps.html#a9a7d9ecdc9068b3fd4a77bb9c949ce50">More...</a><br /></td></tr>
<tr class="separator:a9a7d9ecdc9068b3fd4a77bb9c949ce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8fb62bb057e5cda86732ec98678a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a2e8fb62bb057e5cda86732ec98678a69">operator[]</a> (<a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a> i) const noexcept</td></tr>
<tr class="memdesc:a2e8fb62bb057e5cda86732ec98678a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i-th cap in this instance.  <a href="classghostfragment_1_1Caps.html#a2e8fb62bb057e5cda86732ec98678a69">More...</a><br /></td></tr>
<tr class="separator:a2e8fb62bb057e5cda86732ec98678a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9cf17d1bc466b04a8185b056648f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a6e9cf17d1bc466b04a8185b056648f8f">at</a> (<a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a> i) const</td></tr>
<tr class="memdesc:a6e9cf17d1bc466b04a8185b056648f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retursn the i-th cap in this instance (after a boudns check)  <a href="classghostfragment_1_1Caps.html#a6e9cf17d1bc466b04a8185b056648f8f">More...</a><br /></td></tr>
<tr class="separator:a6e9cf17d1bc466b04a8185b056648f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba3b3511523a1383ebc2c2dac263b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a0ba3b3511523a1383ebc2c2dac263b42">replaced_atom</a> (<a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a> i) const</td></tr>
<tr class="memdesc:a0ba3b3511523a1383ebc2c2dac263b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the supersystem offset of the atom replaced by a cap.  <a href="classghostfragment_1_1Caps.html#a0ba3b3511523a1383ebc2c2dac263b42">More...</a><br /></td></tr>
<tr class="separator:a0ba3b3511523a1383ebc2c2dac263b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be8a937fbf7348597cd83b0612065ee"><td class="memItemLeft" align="right" valign="top">const cap_set_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a2be8a937fbf7348597cd83b0612065ee">nuclei</a> () const noexcept</td></tr>
<tr class="memdesc:a2be8a937fbf7348597cd83b0612065ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of caps.  <a href="classghostfragment_1_1Caps.html#a2be8a937fbf7348597cd83b0612065ee">More...</a><br /></td></tr>
<tr class="separator:a2be8a937fbf7348597cd83b0612065ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e79880be0f06cf6377d3e4ec9df228"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#a59e79880be0f06cf6377d3e4ec9df228">operator==</a> (const <a class="el" href="classghostfragment_1_1Caps.html">Caps</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a59e79880be0f06cf6377d3e4ec9df228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two Cap instances are value equal.  <a href="classghostfragment_1_1Caps.html#a59e79880be0f06cf6377d3e4ec9df228">More...</a><br /></td></tr>
<tr class="separator:a59e79880be0f06cf6377d3e4ec9df228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6831c413ef97eb61957bfc7ae3848"><td class="memItemLeft" align="right" valign="top"><a id="aa8e6831c413ef97eb61957bfc7ae3848"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (type::Hasher &amp;h) const</td></tr>
<tr class="separator:aa8e6831c413ef97eb61957bfc7ae3848"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa5cabaab24179a772b80a3e4b2e3b637"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghostfragment_1_1Caps.html#aa5cabaab24179a772b80a3e4b2e3b637">operator!=</a> (const <a class="el" href="classghostfragment_1_1Caps.html">Caps</a> &amp;lhs, const <a class="el" href="classghostfragment_1_1Caps.html">Caps</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa5cabaab24179a772b80a3e4b2e3b637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instances are different.  <a href="classghostfragment_1_1Caps.html#aa5cabaab24179a772b80a3e4b2e3b637">More...</a><br /></td></tr>
<tr class="separator:aa5cabaab24179a772b80a3e4b2e3b637"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A set of caps. </p>
<p>When fragmenting molecular systems we sometimes need to break covalent bonds. If this happens, the atoms involved in the bond will experience very different electronic environments in the fragment compared to the supersystem (typically the atoms in the fragment are radicals without the bonded atom). To minimize such a perturbation one usually "caps" the severed bonds. This class models the set of caps needed to cap a set of fragments.</p>
<p>Conceptually this class is the union of a type::nuclei_set (which contains the atoms used as caps) and a map detailing which atoms in the supersystem are replaced by which caps. This means that this class assumes that caps are single atoms. Conceivably one can use this class for multi-atom caps, if desired, by a call like:</p>
<div class="fragment"><div class="line">non_default.add_cap(atom0, 0);</div>
<div class="line">non_default.add_cap(atom1, 0);</div>
</div><!-- fragment --><p>i.e., by replacing the same atom with multiple caps. However, this is not tested and may require refactoring to enable.</p>
<p>N.B. this class does NOT keep a sychronized copy of the supersystem (or similarly the fragmented supersystem). Hence it is the user's responsibility to keep the information in this class synchronized with the supersystem and/or fragments (e.g., changing the indices of the supersystem atoms would invalidate calls to <code>replaced_atom</code> without also modifying the <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instance associated with the supersystem). In practice, we have introduced the <a class="el" href="classghostfragment_1_1FragmentedSystem.html" title="Abstraction to describe the initial fragmentation of the supersystem.">FragmentedSystem</a> class for maintaining the various pieces of the fragmented system and keeping them synchronized. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a7d9ecdc9068b3fd4a77bb9c949ce50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7d9ecdc9068b3fd4a77bb9c949ce50">&#9670;&nbsp;</a></span>add_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ghostfragment::Caps::add_cap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghostfragment_1_1Caps.html#a0da5dfb727b6f9af564d6470ddabc5ca">value_type</a>&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a>&#160;</td>
          <td class="paramname"><em>idx_replaced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cap (and the index of the replaced atom) </p>
<p>To effectively manage caps we need not only the cap (i.e. the atomic identy and position), but also what atom it replaces. The latter allows us to automatically work out caps for n-mers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The actual atomic identity of the cap (as specified by a type::nuclei_set::value_type object). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_replaced</td><td>The index of the atom in the supersystem that is replaced by this cap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory for the new cap. Weak throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e9cf17d1bc466b04a8185b056648f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9cf17d1bc466b04a8185b056648f8f">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">Caps::const_reference</a> ghostfragment::Caps::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retursn the i-th cap in this instance (after a boudns check) </p>
<p>This function is the same as <code>operator[]</code> except that it throws if the offset is not in bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The offset for the requested cap. Must be in the range [0, <a class="el" href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67" title="Returns the number of caps in this instance.">size()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An immutable reference to the requested cap.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>i</code> is not in the range [0, <a class="el" href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67" title="Returns the number of caps in this instance.">size()</a>). Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2dd2c379294b50889dda9ae8eb5d437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2dd2c379294b50889dda9ae8eb5d437">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ghostfragment::Caps::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">const_reference</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a cap is in the present set. </p>
<p>The <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> class behaves like an ordered set of caps. This means that a given cap either appears in the instance or does not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The cap we are looking for in the present instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>cap</code> is in the current instance and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be8a937fbf7348597cd83b0612065ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be8a937fbf7348597cd83b0612065ee">&#9670;&nbsp;</a></span>nuclei()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const cap_set_type&amp; ghostfragment::Caps::nuclei </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of caps. </p>
<p>This method provides the type::nuclei_set object holding the caps.</p>
<dl class="section return"><dt>Returns</dt><dd>An immutable reference to the set of caps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e79880be0f06cf6377d3e4ec9df228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e79880be0f06cf6377d3e4ec9df228">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ghostfragment::Caps::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghostfragment_1_1Caps.html">Caps</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two Cap instances are value equal. </p>
<p>Two Cap instances are value equal if they contain the same set of caps, those caps were inserted in the same order, and those caps replace the same atoms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>rhs</code> compares value equal to this instance and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8fb62bb057e5cda86732ec98678a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8fb62bb057e5cda86732ec98678a69">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghostfragment_1_1Caps.html#ae0fa35cb356218c57855b182e13b3ccc">Caps::const_reference</a> ghostfragment::Caps::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the i-th cap in this instance. </p>
<p>This function is used to retrieve a cap by offset. Functionly this is similar to the <code>at</code> method, but differs in that <code>at</code> bounds-checks the offset whereas this function does not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The offset for the requested cap. Assumed to be in the range [0, <a class="el" href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67" title="Returns the number of caps in this instance.">size()</a>), but no bounds check is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An immutable reference to the requested cap (if <code>i</code> is in bounds; undefined behavior ensues if <code>i</code> is not in bounds).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee (even if <code>i</code> is not in bounds). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ba3b3511523a1383ebc2c2dac263b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba3b3511523a1383ebc2c2dac263b42">&#9670;&nbsp;</a></span>replaced_atom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">Caps::size_type</a> ghostfragment::Caps::replaced_atom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the supersystem offset of the atom replaced by a cap. </p>
<p>This method is used to figure out which superset atom is replaced by a cap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the offset of the cap. Must be in the range [0, <a class="el" href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67" title="Returns the number of caps in this instance.">size()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The supersystem offset of the cap being replaced.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>i</code> is not in the range [0, <a class="el" href="classghostfragment_1_1Caps.html#af8cc86d0db9ae98bb6748292b65e0b67" title="Returns the number of caps in this instance.">size()</a>). Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8cc86d0db9ae98bb6748292b65e0b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cc86d0db9ae98bb6748292b65e0b67">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghostfragment_1_1Caps.html#a30da1c9722a0347727fdc31485ba1eca">size_type</a> ghostfragment::Caps::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of caps in this instance. </p>
<p>Each <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instance contains 0 or more caps. This method is used to determine how many caps are in the present instance.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of caps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa5cabaab24179a772b80a3e4b2e3b637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cabaab24179a772b80a3e4b2e3b637">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghostfragment_1_1Caps.html">Caps</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classghostfragment_1_1Caps.html">Caps</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instances are different. </p>
<p>This function simply negates <a class="el" href="classghostfragment_1_1Caps.html#a59e79880be0f06cf6377d3e4ec9df228" title="Determines if two Cap instances are value equal.">Caps::operator==</a>. See the description there for details of what it means for two <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instances to be value equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instance on the left of the not-equal-to operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classghostfragment_1_1Caps.html" title="A set of caps.">Caps</a> instance on the right of the not-equal-to operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> is value equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ghostfragment/<a class="el" href="caps_8hpp_source.html">caps.hpp</a></li>
<li>src/ghostfragment/caps.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
